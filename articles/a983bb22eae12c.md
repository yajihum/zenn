---
title: "Lighthouse CIを使って継続的なパフォーマンスモニタリングを行う"
emoji: "🌞"
type: "tech"
topics: ["lighthouse","docker", "cloudrun", "litestream","cloudflare"]
published: false
---

## はじめに

Webパフォーマンスとは、Webサイトやウェブアプリケーションがユーザーにどれだけ迅速に、効率的に、そして安定してサービスを提供できるかを測定する指標のことを指します。これにはページの読み込み速度、インタラクティブ性、安定性などが含まれます。ユーザー体験を最適化するためには、これらのパフォーマンス指標を継続的に監視し、必要に応じて改善することが重要です。本記事では、そのためのツールとして「Lighthouse CI」を使用して継続的なパフォーマンスモニタリングを行う方法について解説します。

### どうしてパフォーマンスを改善することが重要なのか

誰しも必ず次のような場面に遭遇したことがあると思います。それは例えば、サイトに訪れたとき、5秒以上ずっと真っ白な画面やローディングが流れていたり、ボタンをクリックしたはずなのに何も反応しなかったり、画像の読み込みが遅く最後まで待っても代替テキストしか出てこなかった、というようなものです。これらのユーザーエクスペリエンスは、実際にサービスの評価や利益にも直結していることがわかっています。

https://www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale
上記のBBCによるニュースでは、サイトの読み込みに1秒かかるごとに10%のユーザーをさらに失うということを発表しています。
また、次の記事では楽天がWeb Vitalsという定量的なパフォーマンス指標の改善を図り、訪問者あたりの収益が53.37%、コンバージョン率（Webサイトやページを訪れたユーザーのうち、商品の購入や問い合わせなど、最終的な成果に至った人の割合）が 33.13%増加したとの結果が出ています。
https://web.dev/case-studies/rakuten?hl=ja

このように、Webサイトにおけるパフォーマンスはビジネスとも深く結びついており、継続的な監視と改善が必要です。

### Core Web Vitals について

先ほど出てきたWeb Vitalsとは、Googleが設定しているWebサイトのパフォーマンスを定量的に測定できる指標のことです。その中でも、すべてのウェブページに適用される最も重要な指標として`LCP(Largest Contentful Paint)`、`FID(First Input Delay)`、`CLS(Cumulative Layout Shift)`の3つがあります。

:::message
ただし、FIDについては2024年3月12日から[Interaction to Next Paint（INP）](https://web.dev/articles/inp?hl=ja)に変わるという発表がされています。
https://web.dev/blog/inp-cwv-march-12?hl=ja
:::

:::details Core Web Vitalsの各指標の詳細
- [Largest Contentful Paint（LCP）](https://web.dev/articles/lcp?hl=ja): 読み込みのパフォーマンスを測定します。優れたユーザー エクスペリエンスを提供するため、LCP はページの読み込みが最初に開始してから 2.5 秒以内に発生する必要があります。
- [First Input Delay（FID）](https://web.dev/articles/fid?hl=ja): インタラクティビティを測定します。優れたユーザー エクスペリエンスを提供するには、ページの FID を 100 ミリ秒以下にする必要があります。
- [Cumulative Layout Shift（CLS）](https://web.dev/articles/cls?hl=ja): 視覚的な安定性を測定します。優れたユーザー エクスペリエンスを提供するには、CLS を 0.1. 以下に維持する必要があります。
:::

### Lighthouse とは

上記のような指標の改善を目指すことはWebサイトのパフォーマンス、アクセシビリティ、SEO向上の施策の一つになります。
また、これらの指標を測定するにはいくつかの方法がありますが、より手軽で一般的なものとしてはChromeのデベロッパーツールで見れる[Lighthouse](https://developer.chrome.com/docs/lighthouse/overview/?hl=ja)があります。
例えば、https://web.dev/?hl=ja のページを測定してみると以下のような結果になりました。
![web.devのホームページのLighthouseスコア](https://storage.googleapis.com/zenn-user-upload/4d624e26850b-20240211.png)

赤→黄色→緑の順に良いスコアとなっていきます。Webサイト全体の中でどのページが特にパフォーマンスのスコアが低いかなどを特定したり、その原因をやんわりと掴むのに良いツールです。

##　Lighthouse CIを使って継続的なパフォーマンス監視を行う
### Lighthouse CIとは
https://github.com/GoogleChrome/lighthouse-ci

Lighthouse CI は、継続的インテグレーションで Lighthouse を使用するためのOSSです。例えば、GitHub ActionsのPRのワークフローの中に取り入れ、特定のURLに対してLighthouseを実行し、PRの変更によってパフォーマンスバジェットなどで決めた値を下回らないかなどをチェック項目として取り入れることができます。
また、チェックを使用しない場合も有効で、PRに対して発行されるHTMLのレポートを見ることでチームメンバーがパフォーマンスについて意識するきっかけを作ることができます。

### Lighthouse CI Server を使う
上記のように毎回発行されるレポートを都度見られるようにするだけでもパフォーマンス改善への第一歩になりますが、Lighthouse CIで提供されているLighthouse CI Serverを使うことでPRごとの各指標の遷移をグラフ確認できるようになり、ダッシュボードとして視覚的にわかりやすくスコアを確認できるようになります。

![Lighthouse CI Server のダッシュボードの例](https://storage.googleapis.com/zenn-user-upload/7db34bdda4bf-20240211.png)
*出典：https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/server.md#overview*

今回はこのLighthouse CI Serverを立てて、GitHub Actionsを使ってPR単位でLighthouseを実行し、継続的なスコアの監視ができるように実装していきます。

## Lighthouse CI Server の構築

まず、Lighthouse CI ServerのREADMEのようなものを見て見ると、LHCI ServerのデプロイのためにはHerokuやDockerでできそうなことがわかります。
> See the Heroku and docker recipes for more examples on how to deploy the LHCI server.

また、LHCIを使ったサーバー構築にはNode.jsとDatabase Storage（sqlite, mysql, or postgresql）が必要とのことです。
https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/server.md#requirements

今回は自分のブログサイトを対象にLHCIサーバーを立てたく、個人開発の領域のためあまりお金をかけたくありません。そのため、有料になってしまったHerokuではなくDockerを使ってなるべく安くサーバーを立てられる方法を探します。
Herokuの代わりとしてよくCloud Runでデプロイする方法が挙げられており、無料枠もあるのでCloud Runでデプロイすることに決定します。
しかしここで一つ懸念点があり、Cloud Runはステートレスなサービスであり、各リクエストは新しいコンテナインスタンスで処理されるため、コンテナ内に保存されたデータはリクエストが終了すると消えてしまいます（データの**永続化**ができない）。今回は各PRで生成されたスコアを蓄積する必要があるため、ただCloud Runでデプロイするだけではダメそうです。
そこで調べてみると、LitestreamというOSSを使えばSQLite のデータベースファイルをAmazon S3 や Google Cloud Storage などのオブジェクトストレージにリアルタイムでレプリケートすることができるようです。これでデータの永続化を達成できそうです！

https://zenn.dev/kou_pg_0131/articles/google-cloudrun-litestream#litestream-%E3%81%A8%E3%81%AF%EF%BC%9F

上記の記事では[Cloud Storage](https://cloud.google.com/storage/pricing?hl=ja#asia)を使っているのですが、無料枠がなさそうなので僅かとはいえいくらかはかかってしまいます。そこで、AWS S3互換であり無料枠が大きいCloudflare R2はどうかと思い調べると[使えそう](https://github.com/benbjohnson/litestream/issues/372)だったので、こちらを使うことにします！

😳example作る
LHCIサーバーの最終的なプロジェクトは以下で見れます。
（仮）https://github.com/yajihum/yajihum.dev/tree/main/lhci

## Cloudflare R2 で新しいバケットを作成する

以下の手順で新しいバケットの成とAPIトークンの発行を行います。

1.  Cloudflareのアカウントを持っていない方は新しく作り、ログインします
2. 左のサイドバーがら`R2`のリンクをクリックします
3. 右上にある青い「バケットを作成する」ボタンをクリックし、バケット名を好きなものにし、位置情報はAsia-Pacificにして作成ボタンを押します
4. バケット一覧に戻り、「R2 API トークンの管理」のリンク先に飛びます
5. 「API トークンを作成する」ボタンをクリックします
6. 適当なトークン名を入力し、「管理者読み取りと書き込み」にチェックを入れ後はデフォルトの設定にし、「API トークンを作成する」ボタンをクリックします
7. 表示されたアクセスキーとシークレットアクセスキー、エンドポイントをメモして控えておきます（👁️アクセスキーとシークレットアクセスキーは閉じたら二度と見られないため注意）
これでCloudflare R2の設定は大体完了です！

### package.json の作成

LHCIサーバーはNode.js環境で実行されます。package.jsonを用意します。
以下のレシピにあるpackage.jsonをそのままコピーして作成します。

https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/recipes/docker-server/package.json

### lighthouserc.json の作成

[レシピにあるlitehouserc.json](https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/recipes/docker-server/lighthouserc.json)をそのままコピーして作成します。
😳例を貼る

ここでポート9001を返してやり取りを行うということを少し頭の片隅に入れておきます。
Configurationファイルについては以下で詳しく書かれています。
https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/configuration.md

### Dockerfile の作成

まずはローカルでサーバーを動かして確認するためにイメージをビルドするための
Dockerfileを作成していきます。（先ほどのkokiさんの記事を参考にさせていただきました🙏）
😳Dockerfileの中身のリンク

LHCIサーバーのDockerfileにあるものと組み合わせてビルドステージとランタイムステージの2つに分けています。
特に苦戦したところは、LitestreamからR2のバケットへアクセスする際に証明書関係のエラー[^1]が出てしまい、コンテナを起動できなかったので、以下のように証明書のインストールを行う必要がありました。
```bash
# 証明書のインストール
RUN apt-get update && apt-get install -y ca-certificates
```

litestream.ymlとrun.shは次以降で説明します。

## litestream.yml の作成
litestream.ymlは以下のようになっています。
😳例を貼る

環境変数を通してR2のエンドポイントやアクセスキーなどを代入しています。参照する環境変数を置いておく`.env`ファイルも作成します。
`.env.sample`ファイルを`.env`に名前を変え、エンドポイントURL・バケット名・アクセスキー・シークレットアクセスキーのキーに対して[Cloudflare R2で新しいバケットを作成する](#cloudflare-r2で新しいバケットを作成する)セクションでメモした値をそれぞれ代入します。
この.envファイルの参照はローカルでDocker使用するとき用で、Cloud Runにコンテナをデプロイするときは別で環境変数の設定が必要です。

また、データベースのファイル先は`/data/lhci.db`となっており、これは先ほど作成した`lighthouserc.json`の`sqlDatabasePath`として指定したパスです。

その他、細かな設定は以下を参照してください。
https://litestream.io/reference/config/

##　run.sh ファイルの作成

run.shファイルは以下のように作成します。
😳例を貼る

Litestreamでリストア（データベースファイルの復元）→レプリケート（データベースの内容を復元）してLHCIサーバーをポート9001で`npm start`して起動します。

`npm start`は先ほど作成したpackage.jsonに記載されており、`lhci server --config=./lighthouserc.json`を行うスクリプトです。このコマンドがLHCIサーバーを`lighthouserc.json`を設定ファイルとして起動するという意味になります。


## 参考
https://web.dev/learn/performance/why-speed-matters?hl=ja

[^1]: level=ERROR msg="failed to run" error="cannot fetch generations: RequestError: send request failed\ncaused by: Get \"https://xxxxxxx.r2.cloudflarestorage.com/lighthouse-ci?delimiter=%2F&prefix=generations%2F\": tls: failed to verify certificate: x509: certificate signed by unknown authority"