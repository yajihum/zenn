---
title: "脳死コードを改善する（パフォーマンス編）"
emoji: "👶"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['react', 'nextjs','frontend', 'web', 'パフォーマンス']
published: false
---

## はじめに

今回は、最近の業務の中で小さく始めていたパフォーマンス改善方法について紹介します。
また、筆者は最近[Web Speed Hackathon 2024](https://github.com/yajihum/web-speed-hackathon-2024)に参加したのですが、そこで学んだ知見も踏まえて見ていきたいと思います。

パフォーマンスについて興味がある人もない人もこの記事を見れば、脳死コードを書かずに根拠を持って「ちょっと良いコード」を書けるようになるかも知れません。ぜひ参考にしてもらえると幸いです！

## Core Web Vitalsについて

Webパフォーマンスを計る指標としてWeb Vitalsがありますが、その中でも最も重要な指標として以下の3つのCore Web Vitalsが存在します。
- [Largest Contentful Paint（LCP）](https://web.dev/articles/lcp?hl=ja)
- [Interaction to Next Paint（INP）](https://web.dev/articles/inp?hl=ja)
- [Cumulative Layout Shift（CLS）](https://web.dev/articles/cls?hl=ja)

今回はそれぞれの指標を改善する方法をいくつか紹介します。

## Largest Contentful Paint（LCP）の改善

先ほど挙げた指標のうちの1つである**LCP**の改善方法について紹介します。

### LCPとは

**LCP**について軽く説明します。
この指標は、Webページが読み込まれてから最も大きなコンテンツ（画像やテキストブロックなど）が画面に表示されるまでの時間を測定する指標です。これはページの読み込み速度をユーザーの視点から評価するためのもので、LCPが短いほどユーザーにとってページの読み込みが速く感じられます。

### Suspenseを適切に分割する

みなさんご存知の通り、[Suspense](https://ja.react.dev/reference/react/Suspense)はReactの便利な機能です。
しかし、Suspenseを適切に分割しないと寧ろパフォーマンスを悪くしてしまう状態に陥る可能性があります。

例えば以下のように同じSuspenseコンポーネントの配下に1秒の非同期処理を待つコンポーネントと10秒の処理を待つコンポーネントを配置します。

```tsx: BaseComponent.tsx
export const BaseComponent: React.FC = () => {
  return (
    <div>
      <Suspense fallback={<p>Loading...</p>}>
        <OneSecondWaitComponent />
        <TenSecondsWaitComponent />
      </Suspense>
    </div>
  );
};
```
:::details 各コンポーネントの内容
```tsx: OneSecondWaitComponent.tsx
export const OneSecondWaitComponent: React.FC = () => {
  const { data } = useSuspenseQuery({
    queryKey: ['one-second-wait'],
    queryFn: () => getMssage(1),
  });

  return <p>{data.message}</p>;
};
```
```tsx: TenSecondsWaitComponent.tsx
export const TenSecondsWaitComponent: React.FC = () => {
  const { data } = useSuspenseQuery({
    queryKey: ['ten-seconds-wait'],
    queryFn: () => getMssage(10),
  });

  return <p>{data.message}</p>;
};
```
```ts:lib.ts
export const getMssage = async (
  seconds: number
): Promise<{ message: string }> => {
  await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));
  return {
    message: `${seconds} seconds passed.`,
  };
};
```
今回はフェッチライブラリに[Tanstack Query](https://tanstack.com/query/latest)を使用しています。
:::

この状態で実際のページを見てみると、ずっと`Loading...`の文字が表示されおり、10秒後に`1 seconds passed. 10 seconds passed.`とそれぞれ表示されます。
これはあまり良くない状態です。というのも、1秒後には処理が完了している`OneSecondWaitComponent`コンポーネントを差し置いて10秒が過ぎるまでそのコンテンツを表示できないからです。

改善策は次のようになります。

```tsx: BaseComponent.tsx
export const BaseComponent: React.FC = () => {
  return (
    <div>
      <Suspense fallback={<p>Loading one second data...</p>}>
        <OneSecondWaitComponent />
      </Suspense>
      <Suspense fallback={<p>Loading ten seconds data...</p>}>
        <TenSecondsWaitComponent />
      </Suspense>
    </div>
  );
};
```
Suspenseは子要素でキャッチされた非同期処理が全て完了するまでfallBackを表示するという機能を持っているため、適切に分割して使用する必要があります。
ある非同期処理の結果が別の処理に関係しない場合は別々にコンテンツ表示を行えるはずなので、その際は囲うSuspenseも別々にすると良いでしょう。

これがどうLCPに関係するかというと、例えば`OneSecondWaitComponent`が最も大きなコンテンツとなり、LCPの対象である場合に有効です。
非同期処理を待っている間にローディングを表示して適切なハンドリングをしながら、早く表示できるものはすぐに表示させることが重要です。

また、SSRを使用している場合でもSuspenseを併用するとStreamingHTMLが有効になるため、適切に分割を行うとLCPの改善につながります。

https://tech.anotherworks.co.jp/article/react-suspense-react18

### 画像を最適化する

LCPの対象となるものが画像の場合は最適化をすると読み込みの遅さを改善できます。

例えば以下のように改善すると良いでしょう。
- `<img>` 要素に `fetchpriority="high"`を設定する
- pngや.jpgの画像をwebpにする
- 落としても良い画質まで落とす（圧縮する）
  - 拡張子の変更や圧縮には@squoosh/cliが便利

https://zenn.dev/catnose99/scraps/2647fa64b1fe27
- 画像のリサイズを行う
  - ページ上で表示する画像のサイズと実際の画像のサイズがなるべく等しくなるようにする
  - macOSの場合はデフォルトで`sips`コマンドがある

https://qiita.com/livlea/items/53b755e5067d4ebc5b43

一番最初以外は例えLCP対象でなくても有効です！

また、Next.jsを使用している場合は`<Image>`コンポーネントを使用することでpngをwebpにしてくれたり、ビューポートごとにリサイズされた画像を設定してくれるため、そちらも使うと良いでしょう。

https://nextjs.org/docs/app/api-reference/components/image

## 巨大なBase64エンコーディングを避ける

例えばFigmaで作成したデザインをエクスポートする際にSVGでエクスポートすると場合によってはファイルが巨大になる可能性があります。
```tsx
<svg width="226" height="284" viewBox="0 0 226 284" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
~~~~
<image id="image0_10080_12406" width="1520" height="1916" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABfAAAAd8CAYAAADj16/9AAAKsmlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU+kSgOfe9JAAISECUkJvghSBAFJCaAEUpIONkAQIJcZAULGhsriCa0FFBMuKrooo2Chix4JtUex9QRYRdV0s2FB5FziE3X3nvXfenDNnvkzmn5n/nv+/Zy4AnSWUyzNRTYAsWY4iMsiPE5+QyCF1Aw6owAAAjlCULedFRIRhDCP27/LhDiCD9qbdYK5///+/CkMsyRYBIBEYJ4uzRVkYH8G0VyRX5ADgdmJ+0zk58kG+iDFLgTWI8aNBTh3m3kFOHmI8figmOpKPsQ4AmSYUKlIBaGaDe8kVpWJ5aP4YO8jEUhnG2G/wzsqaJcYYqwtWWIwc48H83OS/5En9W85kVU6hMFXFw3sZErK/NFueKZz3fz6O/y1ZmcqRGhaY0tIUwZGYxfpC7mXMClWxLHly+AhLxUPxQ5ymDI4ZYVE2P3GExUL/UNXazMlhI5wiDRSo8uQIokdYkh0QNcKKWZGqWikKPm+EhYrRusqMGJU/
~~~
</svg>
```
上記にあるbase64エンコーディングで表現されている部分が巨大な文字列になっています。SVGのファイルサイズが大きくなるとバンドルサイズが増え、読み込みに時間がかかりパフォーマンスが低下します。
SVGは解像度が高いため使いたくなりますが、アイコンのような用途以外でSVGを使用するのは避けた方がいいかも知れません。

## Cumulative Layout Shift（CLS）の改善

### CLSとは

そのうちの1つであるCLSについて軽く紹介します。
この指標はビューポート内に表示されているコンテンツのずれやレイアウトシフトがどれくらい起きているかを表すものです。例えば記事を読んでいる際に、最初にレンダリングされた段階では表示されていなかったコンテンツが突如画面の真ん中に表示され、読んでいた箇所がずれて見失ってしまうなどの現象があります。
これはユーザーの体験を損ねるものなので、なるべく解消することが望ましいです。

### CLSは少しの工夫で改善できる

業務中にCLSを気にせず脳死で書いたコードがあるならば、以下のような方法で改善できるかも知れません。

### 




