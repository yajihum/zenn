---
title: "（私も）知っておきたいReactの基本"
emoji: "👋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React"]
published: false
---

## はじめに

先日新しく発表された React の公式ドキュメントを皆さんはご覧になられたでしょうか？
この [react.dev](https://react.dev/) の前に Beta 版があり、筆者は少しずつ読み進めていました。その中で React の基本的な扱い方をほとんど知らないまま使っていたことに気づきました。
しっかりと公式ドキュメントを読み込むことは重要なのだと知り、今回アウトプットとしてまとめてみたので、是非参考にしてもらえると嬉しいです！（GPT の手助けもあります）

GPT は聞いたことしか教えてくれないけど、この記事を読むことで能動的に知識を増やせるししきっと良い事ある！と思って書いてみました。

## Props について

https://beta.reactjs.org/learn/passing-props-to-a-component

Props とは親から子コンポーネントに渡す変数（プロパティ）のことです。
関数の引数のように利用でき、かならずオブジェクトとして渡す必要があります。

```jsx:.jsx
function Avatar({ person, size }) {
  // ...
}

// 渡し方
<Avatar
  size={100}
  person={{
    name: "Katsuko Saruhashi",
    imageId: "YfeOqp2",
  }}
/>;
```

この`{ person, size }`部分では[分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5)が使われています。

この分割代入は、`JavaScript` の`ES6（ECMAScript 2015`で導入された構文で、オブジェクトや配列から特定のプロパティや要素を取り出して、新しい変数に代入することができます。
例えば、上記の例では、`Avatar` コンポーネントに`size`や`person`のプロパティを渡すことでレンダリング時に以下のオブジェクトが生成されます。

```js:js
{
  size: 100,
  person: {
    name: "Katsuko Saruhashi",
    imageId: "YfeOqp2",
  }
}
```

この `props`オブジェクトが`Avatar`関数に引数として渡されます。ここで分割代入の仕組みが登場します。分割代入を使用することで、オブジェクトから特定のプロパティを取り出し、それらを個別の変数として扱うことができます。

## リストのレンダリング

https://react.dev/learn/rendering-lists

### 基本的な使い方（map と filter）

基本的に map や filter を使う

```jsx
import { people } from "./data.js";
import { getImageUrl } from "./utils.js";

export default function List() {
  // filterを使って絞り込み
  const chemists = people.filter((person) => person.profession === "chemist");

  // mapを使って新しい配列を生成
  const listItems = chemists.map((person) => (
    <li>
      <img src={getImageUrl(person)} alt={person.name} />
      <p>
        <b>{person.name}:</b>
        {" " + person.profession + " "}
        known for {person.accomplishment}
      </p>
    </li>
  ));
  return <ul>{listItems}</ul>;
}
```

### リストアイテムには一意の key をつける

map や filter で展開するものには必ず`key`属性を追加する必要があります。

```jsx
const listItems = people.map((person) => (
  // keyを指定する必要がある
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
));
```

これは、どの配列要素に対して変更が起きたかを識別するために必要です。

**★ なぜ key が必要なのかの背景（DOM の再構築）**
React では、仮想 DOM を使用して、コンポーネントの変更を効率的に管理しています。アプリケーションの状態が変化するたびに、React は新しい仮想 DOM ツリーを生成し、それを既存の仮想 DOM ツリーと比較します。この比較プロセスを「`再構築（Reconciliation）`」と呼び、再構築を通じて React は変更があった部分だけを検出し、実際の DOM に効率的に適用します。

その上で、一意で安定した`key`属性を指定することで、React は要素の追加、更新、削除を効率的に検出できます。要素が再利用されたり、順序が変更されたりした場合でも、React は `key`属性を使って要素を特定し、適切な操作を実行します。

`key`属性が指定されていない場合は`index`を用いることで対応されますが、`indexkey`を`key`として用いることが出来るのは、リストが**静的で並び替えや要素の追加・削除がない場合**に限定されます。動的なリストの場合は、一意の ID やデータを元に生成されたハッシュ値などを key として使用することが望ましいとされています。

## コンポーネントを純粋に保つ

https://react.dev/learn/keeping-components-pure

「コンポーネントを純粋に保つ(`Keeping Components Pure`)」とは、あるコンポーネントに同じ props が渡された場合、必ず同じ結果をレンダリングするようにすることです。
レンダリング中に props の変更などで中身が変わってしまってはいけません。

❌ 純粋でないコンポーネント
コンポーネント内で変数を直接変更してしまっています。

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup /> // 2
      <Cup /> // 4
      <Cup /> // 6
    </>
  );
}
```

こうすることで、毎回異なる JSX が生成されてしまい、パフォーマンスが悪くなります。また同時に、他のコンポーネントが`guest`を呼んだタイミングによって都度中身が変わってしまうため、予測不能なバグを生み出してしまうことにもつながります。

⭕ 純粋なコンポーネント
`Cup`の関数内で使われている`guest`は、ただ使われているだけで変更はされていません。

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} /> // 1
      <Cup guest={2} /> // 2
      <Cup guest={3} /> // 3
    </>
  );
}
```

このように、コンポーネントを純粋に保つことで、外部の状態や副作用に依存しないため、予測可能であり、テストやデバッグが容易になります。また、汎用性が高く、再利用が容易になります。純粋な小さな単位のコンポーネントを作成してそれらを組み合わせて複雑な UI を構築することで、メンテナンス性の向上にも繋がります。

### 純粋でないコンポーネントを検知する仕組み

React の`StrictMode`では開発環境でのみ関数は 2 回実行されるようになっています。
これは実際に、関数の中に`console.log `書いてみると確認できます。

先ほどの例でも StrictMode により関数が 2 回実行されているので、❌ 純粋でないコンポーネントでは「2,4,6」と出力されますが、⭕ 純粋なコンポーネントでは「1,2,3」と出力されます。

この`StrictMode`によって関数に同じ引数を渡したとき、必ず同じ結果になって純粋なコンポーネントであるかを確認しています。（レンダリング中に変数の中身が変わったりしてはいけない）

### レンダリングの最初に作成された変数を変更しても問題ない

レンダリング中に変数の中身を変えてしまうのは厳禁ですが、レンダリング中に作成したばかりの変数を変更するのは問題ないものとされます。
例えば、以下のような例です。

```jsx:.jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

`cups`配列が`TeaGathering`関数内で定義されており、その上でレンダリング中に`cups`配列に JSX を`push`しています。
これは、`ローカルミューテーション`と呼ばれ、コンポーネント内で完結している変数の変更は問題ないものとされます。

### 副作用について

`useEffect`などの副作用は、レンダリング中に変更を及ぼすものではなく、レンダリング後に発生するものであるため、純粋に保つ必要はありません。
例えば、イベントハンドラーなどが該当します。

## イベントハンドラーを設定する

### 基本的な使い方

ここでは click イベントを例に挙げます。
`onClick`は React がサポートしているデフォルトの Prop です。

```jsx
// 普通の関数を使う場合
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    // handleClick()ではないことに注意 ただ関数を渡すだけであり実行はしない
    <button onClick={handleClick}>
      Click me
    </button>
  );
}

// アロー関数を使う場合
export default function Button() {
  const handleClick = () => {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

イベントハンドラーを設定する仕組みとしては、`onClick` に `Prop` として 関数を渡し、<button>がその `onClick` を Prop として受け取り、<button>にイベントを設置しています。

また、イベントハンドラーの中身の関数名は`handle~`とするのが一般的です。

> Have names that start with `handle`, followed by the name of the event. By convention, it is common to name event handlers as `handle` followed by the event name. You’ll often see `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`, and so on.

イベントハンドラー Props の名前も好きなように決められます。

↓ の`onPlayMovie`や`onUploadImage`

```jsx
<Toolbar
  onPlayMovie={() => alert("Playing!")}
  onUploadImage={() => alert("Uploading!")}
/>
```

### 関数に引数を渡す場合

Prop として渡す関数を、**アロー関数**にする必要があります。

```jsx
<Button onClick={() => alert("Playing!")}>Play Movie</Button>
```

例えば`onClick={alert(’Playing!’)}`にすると即座に関数が実行されてしまうことになります。これは、イベントハンドラーの中身として Prop を渡すのではなく関数の実行をしてしまっているので誤りです。

## State について

https://react.dev/learn/state-a-components-memory

### State の更新が反映されるタイミング

以下 2 つの State 更新方法の違いを考えてみます。

1️⃣

```jsx
<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>
```

2️⃣

```jsx
<button
  onClick={() => {
    setNumber((n) => n + 1);
    setNumber((n) => n + 1);
    setNumber((n) => n + 1);
  }}
>
  +3
</button>
```

`setNumber`の中身が違いますね。
そして、この 2 つのボタンを押した結果も異なるのです。
1️⃣ では、1 回ボタンを押すと`+1`された値で、2️⃣ では`+3`された値が出力されます。
想定では両方`+3`されるはずでしたが、1️⃣ ではうまく機能していないようです。

1️⃣ の流れとしては以下のようになります。

1. イベントハンドラが実行された時点の変数の値（number）を保持する
2. その変数をイベントハンドラ終了時まで使い、処理を行う
3. イベントハンドラによって更新された値で再レンダリングを行う

React では、ユーザーが操作した（クリックした）時点の状態の`スナップショット`を使用しているため、操作した時に既にあった状態変数の値を使用します。そして、イベントハンドラの処理が終わった後に、コンポーネントが再レンダリングされるという流れです。

また、再レンダリングが行われるのはイベントハンドラ内の関数が全て実行された後であり、それが終わるまでは待機されるようになっています。
この動作をバッチ処理（`batching`）と言います。

この流れにより、複数のコンポーネントから複数の状態変数を更新しても際レンダリングの回数を抑えることができ、かつ処理が全て実行されるまで UI が変化しないことを担保することができます。

一方で、同じイベントハンドラ内で複数回状態変数を変更したい場合は 2️⃣ のような関数を書けば問題ないです。

2️⃣ の流れは以下のようになっています。

1. 最初の`setNumber`で`+1`を行います
2. 次の`setNumber`で 1 で行った最終的な状態変数の値を使って状態変数を更新します
3. 最後までイベントハンドラ内の処理が行われた後、最終的な状態変数を使って再レンダリングが行われます

### State の中身は read-only、 immutable なものとして扱う

immutable と mutable を訳すと...
:::message
immutable：不変な
mutable：変化する
:::

まず、前提として、JavaScript ではデータ型にプリミティブ型とオブジェクト型の 2 つが存在します。
https://qiita.com/ta1fukumoto/items/effaa42cd296a2648d41

プリミティブ型は number や boolean、string などが該当し、例えば以下のように状態変数として設定している値がプリミティブ型であればそれは immutable なものになります。

```jsx
// xはnumber型(=プリミティブなもの)
const [x, setX] = useState(0);
setX(5);
```

この set されている 0 や 5 は、0 または 5 以外に変化させることはできなく、唯一のものでありかつ`read-only`なものです。
React では、このように状態変数を必ず immutable なものにする必要があります。
元からプリミティブ型であれば問題ないですが、オブジェクト型は mutable なものとして扱われます。

**mutable の例**

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });

// mutable
position.x = 5;
```

このようにオブジェクト型は`position.x=5`などとして既にあるオブジェクトの中身の x 変数を好きなように変えられます。
これは、すでに set したものを直接変更しているため`mutable`として扱われます。
React においてこれは厳禁であり、状態変数を変更したにも関わらず再レンダリングも行われません。
なので、以下のようにして read-only でかつ immutable にする必要があります

**immutable の具体例**

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });

// immutable
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

set するときに新しいオブジェクトごと渡すようにします。
これで再レンダリングは正しく行われます。

### State の更新にスプレッド構文を使う

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Spread_syntax

上記のように必ず状態変数を immutable にするために新しいオブジェクトを再度設定するとしても、わざわざ全ての変数を書くのは面倒です。そこでスプレッド構文を使います。

```jsx
setPerson({
  firstName: e.target.value, // New first name from the input
  lastName: person.lastName,
  email: person.email,
});
```

これをスプレッド構文を使うことで以下のように簡潔に書くことができます。

```jsx
setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value, // But override this one
});
```

### 配列の扱い方

ある配列に対して要素を追加したり、削除したりなどなんかしらの操作を行うと思います。その際に、いわゆる**破壊的なメソッド**を使うことは避けるべきとされています。破壊的というのは元の配列自体を操作するようなことです。
例えば、**push・pop・splice・reverse・sort**などが該当します。

具体的に見ていきたいと思います。

1. 要素の追加

❌ push を使用
元の状態変数自体を変更しているため mutable な処理を行なっています。
mutable なものなので再レンダリングも正しく行われません。

```jsx
const [artists, setArtists] = useState([]);

<button
  onClick={() => {
    artists.push({
      id: nextId++,
      name: name,
    });
  }}
>
  Add
</button>;
```

⭕️ 新しい配列を生成
先ほどのスプレッド構文をうまく使って新しい配列を生成し、状態変数として set しています。
再レンダリングも正しく行われます。

```jsx
<button
  onClick={() => {
    setArtists([...artists, { id: nextId++, name: name }]);
  }}
>
  Add
</button>
```

2. 要素の削除

⭕️ filter を使って新しい配列を生成

```jsx
<button onClick={() => {
  setArtists(
    artists.filter(a =>
      a.id !== artist.id
    )
  );
}}>
```

3. 配列の中身を変える

⭕️ map を使って新しい配列を生成

```jsx
let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

...

function handleClick() {
  const nextShapes = shapes.map(shape => {
    if (shape.type === 'square') {
      // No change
      return shape;
    } else {
      // Return a new circle 50px below
      return {
        ...shape,
        y: shape.y + 50,
      };
    }
  });
  // Re-render with the new array
  setShapes(nextShapes);
}
```

4. n 番目の要素の中身を変える

⭕️ map を使って新しい配列を生成
クリックした要素のインデックスを取得し、そのインデックスと一致する時だけ異なる処理を行います。

```jsx
function handleIncrementClick(index) {
  const nextCounters = counters.map((c, i) => {
    if (i === index) {
      // Increment the clicked counter
      return c + 1;
    } else {
      // The rest haven't changed
      return c;
    }
  });
  setCounters(nextCounters);
}
```

5. 配列の途中に要素を追加する

⭕️ slice を使う

```jsx
function handleClick() {
  const insertAt = 1; // Could be any index
  const nextArtists = [
    // Items before the insertion point:
    ...artists.slice(0, insertAt),
    // New item:
    { id: nextId++, name: name },
    // Items after the insertion point:
    ...artists.slice(insertAt),
  ];
  setArtists(nextArtists);
  setName("");
}
```

6. 逆順やソートを行う

⭕️`reverse()`や `sort()`する時には新しい配列を作成し、その配列に対して行います。

```jsx
function handleClick() {
  const nextList = [...list];
  nextList.reverse();
  setList(nextList);
}
```

### 複数の State を管理する方法

https://react.dev/learn/choosing-the-state-structure
以下のようなことを意識して State を構造化・管理するといいとのことです。

1.  関係する複数の State はまとめる
    例えば 1 つの操作に対して複数の State を更新するときは、1 つの State にまとめられます。

```jsx
const [x, setX] = useState(0);
const [y, setY] = useState(0);

// ↑を↓にまとめられる
const [position, setPosition] = useState({ x: 0, y: 0 });
```

2.  State 同士の矛盾を作らない
    複数の State が必ず起こり得ない状態を作っている場合は見直すようにします。

```jsx
// この2つが同時にtrueになることはない
const [isSending, setIsSending] = useState(false);
const [isSent, setIsSent] = useState(false);

// リファクタリング後
const [status, setStatus] = useState("typing");

const isSending = status === "sending";
const isSent = status === "sent";
```

3.  State を冗長的に増やさない
    例えば、以下のような例を考えます。

```jsx
function App() {
  const [text, setText] = useState("");

  const handleChange = (event) => {
    setText(event.target.value);
  };

  const textLength = text.length;

  return (
    <div>
      <input type="text" value={text} onChange={handleChange} />
      <p>You have entered {textLength} characters.</p>
    </div>
  );
}
```

`textLength`は、State として管理されている`text`から計算されたものであり、State として管理する必要はないものです。
もし、この`textLength`をも State として管理しているならば、それは冗長的と言えます。

4. 同一の変数を複数の State で管理しない
   複数で管理すると同期させるのが難しくなってしまいます。

```jsx
// itemsの中にselectedItemが必ず含まれているので重複している
// itemsだけを更新してselectedItemを更新し忘れるとミスが発生してしまう
const [items, setItems] = useState(initialItems);
const [selectedItem, setSelectedItem] = useState(items[0]);

// リファクタリング
// IdをStateとして管理することで重複をなくせる
const [items, setItems] = useState(initialItems);
const [selectedId, setSelectedId] = useState(0);

const selectedItem = items.find((item) => item.id === selectedId);
```

5. 深いネスト状態を持つ State を作らない
   可能な限り浅くて平らな State にします。そうすることで State の更新など管理がしやすくなります。

```jsx
// ３階層の深いネストのオブジェクト
export const initialTravelPlan = {
  id: 0,
  title: '(Root)',
  childPlaces: [{
    id: 1,
    title: 'Earth',
    childPlaces: [{
      id: 2,
      title: 'Africa',
      childPlaces: [{
        id: 3,
        title: 'Botswana',
        childPlaces: []
      }, {
        id: 4,
        title: 'Egypt',
        childPlaces: []
      },
...
}

// リファクタリング
// idで結びつける
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 43, 47],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 27, 35]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  },
...
```

🔆 親から受け継いだ Props をそのまま使うときは子コンポーネントの State に詰め替えなくて良い
例えば以下のような例です。

```jsx
function Message({ messageColor }) {
  // NG
  const [color, setColor] = useState(messageColor);

　//　OK
　const color = messageColor;
```

ただし、子コンポーネントで親の Props を上書きしたい場合は State を使うのが正しいです。
