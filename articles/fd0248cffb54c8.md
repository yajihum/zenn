---
title: "新ドキュメントから学ぶReactの基本"
emoji: "👋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React"]
published: false
---

## はじめに

先日新しく発表された React の公式ドキュメントを皆さんはご覧になられたでしょうか？
この [react.dev](https://react.dev/) の前に Beta 版があり、筆者は少しずつ読み進めていました。その中で React の基本的な扱い方をほとんど知らないまま使っていたことに気づきました。
しっかりと公式ドキュメントを読み込むことは重要なのだと知り、今回アウトプットとしてまとめてみたので、是非参考にしてもらえると嬉しいです！（GPT の手助けもあります）

## Props について

https://beta.reactjs.org/learn/passing-props-to-a-component

Props とは親から子コンポーネントに渡す変数（プロパティ）のことです。
関数の引数のように利用でき、かならずオブジェクトとして渡す必要があります。

```jsx:.jsx
function Avatar({ person, size }) {
  // ...
}

// 渡し方
<Avatar
  size={100}
  person={{
    name: "Katsuko Saruhashi",
    imageId: "YfeOqp2",
  }}
/>;
```

この`{ person, size }`部分では[分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5)が使われています。

この分割代入は、`JavaScript` の`ES6（ECMAScript 2015`で導入された構文で、オブジェクトや配列から特定のプロパティや要素を取り出して、新しい変数に代入することができます。
例えば、上記の例では、`Avatar` コンポーネントに`size`や`person`のプロパティを渡すことでレンダリング時に以下のオブジェクトが生成されます。

```js:js
{
  size: 100,
  person: {
    name: "Katsuko Saruhashi",
    imageId: "YfeOqp2",
  }
}
```

この `props`オブジェクトが`Avatar`関数に引数として渡されます。ここで分割代入の仕組みが登場します。分割代入を使用することで、オブジェクトから特定のプロパティを取り出し、それらを個別の変数として扱うことができます。

## リストのレンダリング

https://react.dev/learn/rendering-lists

### 基本的な使い方（map と filter）

基本的に map や filter を使う

```jsx
import { people } from "./data.js";
import { getImageUrl } from "./utils.js";

export default function List() {
  // filterを使って絞り込み
  const chemists = people.filter((person) => person.profession === "chemist");

  // mapを使って新しい配列を生成
  const listItems = chemists.map((person) => (
    <li>
      <img src={getImageUrl(person)} alt={person.name} />
      <p>
        <b>{person.name}:</b>
        {" " + person.profession + " "}
        known for {person.accomplishment}
      </p>
    </li>
  ));
  return <ul>{listItems}</ul>;
}
```

### リストアイテムには一意の key をつける

map や filter で展開するものには必ず`key`属性を追加する必要があります。

```jsx
const listItems = people.map((person) => (
  // keyを指定する必要がある
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
));
```

これは、どの配列要素に対して変更が起きたかを識別するために必要です。

> Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen `key`
> helps React infer what exactly has happened, and make the correct updates to the DOM tree.

**★ なぜ key が必要なのかの背景（DOM の再構築）**
React では、仮想 DOM を使用して、コンポーネントの変更を効率的に管理しています。アプリケーションの状態が変化するたびに、React は新しい仮想 DOM ツリーを生成し、それを既存の仮想 DOM ツリーと比較します。この比較プロセスは「`再構築（Reconciliation）`」と呼ばれています。再構築を通じて、React は変更があった部分だけを検出し、実際の DOM に効率的に適用します。

`key`属性を指定することで、React は要素の追加、更新、削除を効率的に検出できます。
`key`属性には、一意で安定した値を指定することが推奨されています。要素が再利用されたり、順序が変更されたりした場合でも、React は `key`属性を使って要素を特定し、適切な操作を実行します。

`key`属性が指定されていない場合は`index`を用いることで対応されますが、`indexkey`を`key`として用いることが出来るのは、リストが**静的で並び替えや要素の追加・削除がない場合**に限定されます。動的なリストの場合は、一意の ID やデータを元に生成されたハッシュ値などを key として使用することが望ましいとされています。

## コンポーネントを純粋に保つ

https://react.dev/learn/keeping-components-pure

「コンポーネントを純粋に保つ(`Keeping Components Pure`)」とは、あるコンポーネントが同じ props が渡された場合、必ず同じ結果をレンダリングするようにすることです。
レンダリング中に props の変更などで中身が変わってしまってはいけません。

❌ 純粋でないコンポーネント
コンポーネント内で変数を直接変更してしまっています。

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup /> // 2
      <Cup /> // 4
      <Cup /> // 6
    </>
  );
}
```

こうすることで、毎回異なる JSX が生成されてしまい、パフォーマンスが悪くなります。また同時に、他のコンポーネントが`guest`を呼んだタイミングによって都度中身が変わってしまうため、予測不能なバグを生み出してしまうことにもつながります。

⭕ 純粋なコンポーネント
`Cup`の関数内で使われている`guest`は、ただ使われているだけで変更はされていません。

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} /> // 1
      <Cup guest={2} /> // 2
      <Cup guest={3} /> // 3
    </>
  );
}
```

このように、コンポーネントを純粋に保つことで、外部の状態や副作用に依存しないため、予測可能であり、テストやデバッグが容易になります。また、汎用性が高く、再利用が容易になります。純粋な小さな単位のコンポーネントを作成してそれらを組み合わせて複雑な UI を構築することで、メンテナンス性の向上にも繋がります。

### 純粋でないコンポーネントを検知する仕組み

React の`StrictMode`では開発環境でのみ関数は 2 回実行されるようになっています。
これは実際に、関数の中に`console.log `書いてみると確認できます。

先ほどの例でも StrictMode により関数が 2 回実行されているので、❌ 純粋でないコンポーネントでは「2,4,6」と出力されますが、⭕ 純粋なコンポーネントでは「1,2,3」と出力されます。

この`StrictMode`によって関数に同じ引数を渡したとき、必ず同じ結果になって純粋なコンポーネントであるかを確認しています。（レンダリング中に変数の中身が変わったりしてはいけない）

### レンダリングの最初に作成された変数を変更しても問題ない

レンダリング中に変数の中身を変えてしまうのは厳禁ですが、レンダリング中に作成したばかりの変数を変更するのは問題ないものとされます。
例えば、以下のような例です。

```jsx:.jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

`cups`配列が`TeaGathering`関数内で定義されており、その上でレンダリング中に`cups`配列に JSX を`push`しています。
これは、`ローカルミューテーション`と呼ばれ、コンポーネント内で完結している変数の変更は問題ないものとされます。

### 副作用について

`useEffect`などの副作用は、レンダリング中に変更を及ぼすものではなく、レンダリング後に発生するものであるため、純粋に保つ必要はありません。
例えば、イベントハンドラーなどが該当します。

## イベントハンドラーを設定する

### 基本的な使い方

ここでは click イベントを例に挙げる

onClick は React がサポートしているデフォルトの Prop

```jsx
// 普通の関数を使う場合
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    // handleClick()ではないことに注意 ただ関数を渡すだけであり実行はしない
    <button onClick={handleClick}>
      Click me
    </button>
  );
}

// アロー関数を使う場合
export default function Button() {
  const handleClick = () => {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

イベントハンドラーを設定する仕組みとしては、onClick に Prop として function を渡し、<button>がその onClick を Prop として受け取り、<button>にイベントを設置している

> Finally, your `Button` component accepts a prop called `onClick`. It passes that prop directly to the built-in browser `<button>`with `onClick={onClick}`. This tells React to call the passed function on click.

イベントハンドラーの中身の関数名は`handle~`とするのが一般的

> Have names that start with `handle`, followed by the name of the event. By convention, it is common to name event handlers as `handle` followed by the event name. You’ll often see `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`, and so on.

イベントハンドラー Props の名前も好きなように決められる

↓ の`onPlayMovie`や`onUploadImage`

```jsx
<Toolbar
  onPlayMovie={() => alert("Playing!")}
  onUploadImage={() => alert("Uploading!")}
/>
```

### 関数に引数を渡す場合

アロー関数にする必要がある

```jsx
<Button onClick={() => alert("Playing!")}>Play Movie</Button>
```

例えば`onClick={alert(’Playing!’)}`にすると即座に関数が実行されてしまうことになる

これは、イベントハンドラーの中身として Prop を渡すのではなく関数の実行をしてしまっているので誤り

> In the second example, the `()`at the end of `handleClick()`fires the function _immediately_ during [rendering](https://beta.reactjs.org/learn/render-and-commit), without any clicks. This is because JavaScript inside the [JSX `{` and `}`](https://beta.reactjs.org/learn/javascript-in-jsx-with-curly-braces)
> executes right away.

---

## State について

### State の更新が反映されるタイミング

このページにまとまっている

[State as a Snapshot](https://beta.reactjs.org/learn/state-as-a-snapshot)

この[State over time](https://beta.reactjs.org/learn/state-as-a-snapshot#state-over-time)を試してみる

`+5`ボタンをクリックすると、状態変数である number を表示するアラートでは、何の数字が表示されるだろうか？

答えは`0`であり、クリックした後の`5`は表示されない

React では、ユーザーが操作した（クリックした）時点の状態の`スナップショット`を使用しているため、click 時点の 0 が表示されることになる

また、再レンダリングが行われるのはイベントハンドラ内の関数が全て実行された後であり、それが終わるまでは待機されるようになっている

この動作をバッチ処理という（`batching`）

> The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!

> **A state variable’s value never changes within a render,** even if its event handler’s code is asynchronous. Inside _that render’s_ `onClick`, the value of `number` continues to be `0` even after `setNumber(number + 5)` was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component.

> **React waits until _all_ code in the event handlers has run before processing your state updates.**This is why the re-render only happens _after_ all these `setNumber()`calls.

そして、クリックされた後の`number=5`の状態で再度クリックが発生したときにアラートで`5`が表示される仕組みになっている

### State の Replace と Update の違い

Replace

```jsx
const [number, setNumber] = useState(0);

<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>;
```

この`number+1`は Replace に該当し、`number=0+1=1`に置き換えている

他の 2 つの`setNumber()`は同じく`number=0+1=1`を行っているため再レンダリングされた後は`number=1`となる

一方で number が更新されるパターンは以下のようになる

```jsx
const [number, setNumber] = useState(0);

return (
  <button
    onClick={() => {
      setNumber((n) => n + 1);
      setNumber((n) => n + 1);
    }}
  >
    Increase the number
  </button>
);
```

`n`を引数として受け取り、それを書き換え（update）しているので

`0⇒0+1=1`、`1⇒1+1=2`となり同じ関数内で書き換わる

### State の中身は immutable なものとして扱う

immutable=不変

mutable=変化する

mutable の具体例

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });

// mutable
position.x = 5;
```

immutable の具体例

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });

// immutable
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

State の中身は必ず immutable、つまり不変のものとして扱う必要がある

不変のものとは、上のように新しいオブジェクトをそのまま渡したり、`read-only`のものとすることである

### Immer おもろ

[Updating Objects in State](https://beta.reactjs.org/learn/updating-objects-in-state#write-concise-update-logic-with-immer)

### 配列の Update

[Updating Arrays in State](https://beta.reactjs.org/learn/updating-arrays-in-state#updating-arrays-without-mutation)

基本破壊的とされるメソッドは使わない

![Untitled](%E3%81%93%E3%82%8C%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8F%E3%81%A8%E3%81%84%E3%81%84%E3%81%8B%E3%82%82%204e77d0a5954348a790aa0354a934d61a/Untitled%203.png)

**参考**

プリミティブ型（=immutable）とオブジェクト型（=mutable）

[【JavaScript】プリミティブ型とオブジェクト型を理解したい - Qiita](https://qiita.com/ta1fukumoto/items/effaa42cd296a2648d41)
